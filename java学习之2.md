# java基础之JVM
## 1.2Java内存模型——原子性、内存可见性、重排序、顺序一致性、volatile、锁、final
### 一、原子性
#### 原子性操作指相应的操作是单一不可分割的操作。例如，对int变量count执行count++d操作就不是原子性操作。因为count++实际上可以分解为3个操作：（1）读取变量count的当前值；（2）拿count的当前值和1做加法运算；（3）将加完后的值赋给count变量。

#### 在多线程环境中，非原子操作可能会受其他线程的干扰。比如，上述例子如果没有对相应的代码进行同步（Synchronization）处理，则可能出现在执行第2个操作的时候，count变量的值已经被其他线程修改过了。当然，synchronized关键字可以帮助我们实现原子性操作，以避免这种线程间的干扰情况。

#### synchronized关键字可以实现操作的原子性，其实质是：通过该关键字所包括的临界区（Critical Section）的排他性保证在任何一个时刻只有一个线程能够执行临界区中的代码，这使得临界区中的代码代表了一个原子操作。这一点，大家基本都很清楚。但是，synchronized关键字所起到的另一个作用——保证内存的可见性（Memory Visibility），也是我们值得回顾的地方。

### 二、内存可见性
#### CPU在执行代码的时候，为了减少变量访问的时间消耗可能将代码中访问的变量的值缓存到该CPU缓存区中，因此，相应的代码再次访问该变量的时候，相应的值可能从CPU缓存中而不是主内存中读取的。同样的，代码对这些被缓存过的变量的值的修改也可能仅是被写入CPU缓存区，而没有写入主内存。由于每个CPU都有自己的缓存区，因此一个CPU缓存区中的内容对于其他CPU而言是不可见的。这就导致了在其他CPU上运行的其他线程可能无法“看到”该线程对某个变量值的更改。这就是所谓的内存可见性。

#### synchronized关键字的另一个作用就是保证了一个线程执行临界区中的代码时，所修改的变量值对于稍后执行该临界区的线程来说是可见的。这对于保证多线程代码的正确性来说非常重要。

#### 而volatile关键字也能够保证内存可见性。即一个线程对一个采用volatile关键字修饰的变量的值的更改，对于其他访问该变量的线程而言总是可见的。也就是说，其他线程不会读到一个“过期”的变量值。因此，有人将volatile关键字和synchronized关键字所代表的内部锁做比较，将其称为轻量级的锁。这种称呼其实并不恰当，volatile关键字只能保证内存可见性，它并不能像synchronized关键字所代表的内部锁那样能够保证操作的原子性。volatile关键字实现内存可见性的核心机制是：当一个线程修改了一个volatile修饰的变量的值时，该值会被写入主内存（即RAM）而不仅仅是当前线程所在的CPU的缓存区，而其他CPU的缓存区中存储的该变量的值也会因此而失效（从而得以更新为主内存中该变量的“新值”）。这就保证了其他线程访问该volatile修饰的变量时，总是可以获取到该变量的最新值。

### 三、指令重排序
#### volatile关键字的另一个作用是：它禁止了指令重排序（Re-order）。编译器和CPU为了提高指令的执行效率可能会进行指令重排序，这使得代码的实际执行方式可能不是按照我们所认为的方式进行。例如下面的实例变量初始化语句：

(`private SomeClass someObject = new SomeClass();`)

#### 上述语句非常简单：（1）创建类SomeClass 的实例；（2）将类SomeClass 的实例的引用赋给变量someObject 。但是由于指令的重排序作用，这段代码的实际执行顺序可能是：（1）分配一段用于存储SomeClass 实例的内存空间；（2）将对该内存空间的引用赋给变量someObject；（3）创建类SomeClass 的实例。因此，当其他线程访问someObject变量的值时，其得到的仅是指向一段存储SomeClass 实例的的内存空间的引用而已，而该内存空间相应的SomeClass 实例的初始化可能尚未完成，这就可能导致一些意想不到的结果。而禁止指令重排序则是可以使得上述代码按照我们所期望的顺序（正如代码所表达的顺序）来执行。

#### 禁止指令重排序虽然导致编译器和CPU无法对一些指令进行可能的优化，但是它某种程度上让代码执行看起来更符合我们的期望。

#### Volatile、synchronized两者的区别联系
#### 1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
#### 2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
#### 3.volatile仅能实现变量的修改可见性，不能保证原子性（线程A修改了变量还没结束时,另外的线程B可以看到已修改的值,而且可以修改这个变量,而不用等待A释放锁,因为Volatile 变量没上锁）；而synchronized则可以保证变量的修改可见性和原子性。
#### 4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞和上下文切换。
#### 5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

#### 6.在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原子操作。当变量的值由自身决定时，如n=n+1、n++ 等，volatile关键字将失效。只有当变量的值和自身无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。
#### 7.“锁是昂贵的”，谨慎使用锁机制。

### 四、顺序一致性


#### 数据竞争与顺序一致性保证
#### 当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：

#### 在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序。当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。

#### JMM对正确同步的多线程程序的内存一致性做了如下保证：

#### 如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。
#### 顺序一致性内存模型
#### 顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：

#### 一个线程中的所有操作必须按照程序的顺序来执行。
#### （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。
